#include <algorithm>
#include "fuzzylogic.h"

/////////////////////////////////////////////////////////////////

//Initialise Fuzzy Rules

void initFuzzyRules(fuzzy_system_rec *fl) {
	
   // 规则总数设置为 25 (5x5 矩阵)
   const int no_of_combined_rules = 25;
   int i;
	
//---------------------------------------------------------------------------- 	
// X vs. Y (Combined Inputs)
//
   for (i = 0;i < no_of_combined_rules;i++) {
       fl->rules[i].inp_index[0] = INPUT_X; // X 组合输入
       fl->rules[i].inp_index[1] = INPUT_Y; // Y 组合输入
   }
      
   /* 规则矩阵 (X \ Y): NL, NS, ZE, PS, PL */
   /* 输出: NVL, NL, NM, NS, ZE, PS, PM, PL, PVL */
   
   // 这里采用一个常见的倒立摆模糊控制规则矩阵作为示例起点。
   // 你应该参考 Yamakawa 的论文（或实验）来定义你的规则。
   
   // 规则索引 (i) 从 0 到 24 
   
   // 假设规则矩阵 (X \ Y) 的布局是：
   // X 是行 (i=0..4)，Y 是列 (j=0..4)
   // i = 5*row + col
   
   // R1: X=NL
   //     Y: NL, NS, ZE, PS, PL
   fl->rules[0].inp_fuzzy_set[0] = in_nl; fl->rules[0].inp_fuzzy_set[1] = in_nl; fl->rules[0].out_fuzzy_set = out_pm; // Y=NL (抵消最少) -> PM (+6.0)
   fl->rules[1].inp_fuzzy_set[0] = in_nl; fl->rules[1].inp_fuzzy_set[1] = in_ns; fl->rules[1].out_fuzzy_set = out_pl; // Y=NS (较少抵消) -> PL (+10.0)
   fl->rules[2].inp_fuzzy_set[0] = in_nl; fl->rules[2].inp_fuzzy_set[1] = in_ze; fl->rules[2].out_fuzzy_set = out_pvl; // Y=ZE (无抵消) -> PVL (+15.0)
   fl->rules[3].inp_fuzzy_set[0] = in_nl; fl->rules[3].inp_fuzzy_set[1] = in_ps; fl->rules[3].out_fuzzy_set = out_pl; // Y=PS (较多抵消) -> PL (+10.0)
   fl->rules[4].inp_fuzzy_set[0] = in_nl; fl->rules[4].inp_fuzzy_set[1] = in_pl; fl->rules[4].out_fuzzy_set = out_pm; // Y=PL (最多抵消) -> PM (+6.0)

  
   
   // R2: X=NS
   //     Y: NL, NS, ZE, PS, PL
   fl->rules[5].inp_fuzzy_set[0] = in_ns; fl->rules[5].inp_fuzzy_set[1] = in_nl; fl->rules[5].out_fuzzy_set = out_ze; // 1,0 -> ZE
   fl->rules[6].inp_fuzzy_set[0] = in_ns; fl->rules[6].inp_fuzzy_set[1] = in_ns; fl->rules[6].out_fuzzy_set = out_nm; // 1,1 -> NM
   fl->rules[7].inp_fuzzy_set[0] = in_ns; fl->rules[7].inp_fuzzy_set[1] = in_ze; fl->rules[7].out_fuzzy_set = out_nl; // 1,2 -> NL
   fl->rules[8].inp_fuzzy_set[0] = in_ns; fl->rules[8].inp_fuzzy_set[1] = in_ps; fl->rules[8].out_fuzzy_set = out_nm; // 1,3 -> NM
   fl->rules[9].inp_fuzzy_set[0] = in_ns; fl->rules[9].inp_fuzzy_set[1] = in_pl; fl->rules[9].out_fuzzy_set = out_ze; // 1,4 -> ZE

   // R3: X=ZE
   //     Y: NL, NS, ZE, PS, PL
   fl->rules[10].out_fuzzy_set = out_pvl; // Y=NL, F=+15.0
   fl->rules[11].out_fuzzy_set = out_pl;  // Y=NS, F=+10.0
   fl->rules[12].out_fuzzy_set = out_ze;  // Y=ZE, F=0.0
   fl->rules[13].out_fuzzy_set = out_nl;  // Y=PS, F=-10.0
   fl->rules[14].out_fuzzy_set = out_nvl; // Y=PL, F=-15.0```

   // R4: X=PS
   //     Y: NL, NS, ZE, PS, PL
   fl->rules[15].inp_fuzzy_set[0] = in_ps; fl->rules[15].inp_fuzzy_set[1] = in_nl; fl->rules[15].out_fuzzy_set = out_ze; // 3,0 -> ZE
   fl->rules[16].inp_fuzzy_set[0] = in_ps; fl->rules[16].inp_fuzzy_set[1] = in_ns; fl->rules[16].out_fuzzy_set = out_pm; // 3,1 -> PM
   fl->rules[17].inp_fuzzy_set[0] = in_ps; fl->rules[17].inp_fuzzy_set[1] = in_ze; fl->rules[17].out_fuzzy_set = out_pl; // 3,2 -> PL
   fl->rules[18].inp_fuzzy_set[0] = in_ps; fl->rules[18].inp_fuzzy_set[1] = in_ps; fl->rules[18].out_fuzzy_set = out_pm; // 3,3 -> PM
   fl->rules[19].inp_fuzzy_set[0] = in_ps; fl->rules[19].inp_fuzzy_set[1] = in_pl; fl->rules[19].out_fuzzy_set = out_ze; // 3,4 -> ZE

   // R5: X=PL
   //     Y: NL, NS, ZE, PS, PL
   fl->rules[20].inp_fuzzy_set[0] = in_pl; fl->rules[20].inp_fuzzy_set[1] = in_nl; fl->rules[20].out_fuzzy_set = out_nm; // 4,0 -> NM (-6.0)
   fl->rules[21].inp_fuzzy_set[0] = in_pl; fl->rules[21].inp_fuzzy_set[1] = in_ns; fl->rules[21].out_fuzzy_set = out_nl; // 4,1 -> NL (-10.0)
   fl->rules[22].inp_fuzzy_set[0] = in_pl; fl->rules[22].inp_fuzzy_set[1] = in_ze; fl->rules[22].out_fuzzy_set = out_nvl; // 4,2 -> NVL (-15.0)
   fl->rules[23].inp_fuzzy_set[0] = in_pl; fl->rules[23].inp_fuzzy_set[1] = in_ps; fl->rules[23].out_fuzzy_set = out_nl; // 4,3 -> NL (-10.0)
   fl->rules[24].inp_fuzzy_set[0] = in_pl; fl->rules[24].inp_fuzzy_set[1] = in_pl; fl->rules[24].out_fuzzy_set = out_nm; // 4,4 -> NM (-6.0)
      return;
}


void initMembershipFunctions(fuzzy_system_rec *fl) {
	
      /* The Combined Input X membership functions (e.g. [-4.0, 4.0]) */
   // 假设使用五个模糊集: 负大(NL), 负小(NS), 零(ZE), 正小(PS), 正大(PL)
   // NL (-20.0 到 -1.5)
   fl->inp_mem_fns[INPUT_X][in_nl] = init_trapz (-20.0, -2.0, 0.0, 0.0, left_trapezoid); // NL 结束于 -2.0
   
   fl->inp_mem_fns[INPUT_X][in_ns] = init_trapz (-2.0, -1.5, -0.5, 0.0, regular_trapezoid); 
   fl->inp_mem_fns[INPUT_X][in_ze] = init_trapz (-1.5, -0.5, 0.5, 1.5, regular_trapezoid); // 外部边界扩大到 1.5
   fl->inp_mem_fns[INPUT_X][in_ps] = init_trapz (0.0, 0.5, 1.5, 2.0, regular_trapezoid); // 确保与 ZE 衔接
   
   // PL (15.0 到 20.0)
   fl->inp_mem_fns[INPUT_X][in_pl] = init_trapz (15.0, 20.0, 0.0, 0.0, right_trapezoid);

   /* The Combined Input Y membership functions (e.g. [-4.0, 4.0]) */
   // Y 的模糊集定义可以与 X 相同，作为起始点
   
   // NL (Negative Large) - 左梯形
   fl->inp_mem_fns[INPUT_Y][in_nl] = init_trapz (-30.0, -18.0, 0.0, 0.0, left_trapezoid);
   
   // NS (Negative Small) - 确保 d 覆盖 ZE 的外部边界 a
   // NS 应该在 -4.0 处结束，与 ZE 的 -4.0 完美衔接
   fl->inp_mem_fns[INPUT_Y][in_ns] = init_trapz (-18.0, -6.0, -4.0, 0.0, regular_trapezoid); 
   
   // ZE (Zero) - 扩大外部边界到 4.0，平顶保持 [-0.5, 0.5]
   fl->inp_mem_fns[INPUT_Y][in_ze] = init_trapz (-4.0, -0.5, 0.5, 4.0, regular_trapezoid); // 外部边界扩大到 4.0
   
   // PS (Positive Small) - 确保 a 覆盖 ZE 的外部边界 d
   // PS 应该在 4.0 处开始
   fl->inp_mem_fns[INPUT_Y][in_ps] = init_trapz (0.0, 4.0, 6.0, 18.0, regular_trapezoid); // 从 0.0 开始斜坡，在 4.0 处达到 1.0
   
   // PL (Positive Large) - 右梯形
   fl->inp_mem_fns[INPUT_Y][in_pl] = init_trapz (18.0, 30.0, 0.0, 0.0, right_trapezoid);
	
   return;
}

void initFuzzySystem (fuzzy_system_rec *fl) {

   //Note: The settings of these parameters will depend upon your fuzzy system design
   fl->no_of_inputs = 2;  /* Inputs are handled 2 at a time only */
   fl->no_of_rules = 25;
   fl->no_of_inp_regions = 5;
   fl->no_of_outputs = 9;
	
   coefficient_A=50.0;   // 角度权重
   coefficient_B=10.0;   // 角速度权重   
   
   coefficient_C=15.0;   // 保持不变（你成功的归位牵引力）
   coefficient_D=20.0;   // 提高阻尼力 (从 2.0 提高到 10.0)
	
	// **修改这里：定义规则输出常数 (力的值)**
   fl->output_values [out_nvl]=-15.0; 
	fl->output_values [out_nl] = -10.0; // 较小的 NL
	fl->output_values [out_nm] = -6.0;  
	fl->output_values [out_ns] = -2.0;  // 微小的 NS
	fl->output_values [out_ze] = 0.0;   
	fl->output_values [out_ps] = 2.0;   
	fl->output_values [out_pm] = 6.0;   
	fl->output_values [out_pl] = 10.0;  
	fl->output_values [out_pvl]= 15.0;
   

   fl->rules = (rule *) malloc ((size_t)(fl->no_of_rules*sizeof(rule)));
   initFuzzyRules(fl);
   initMembershipFunctions(fl);
   return;
}

//////////////////////////////////////////////////////////////////////////////

trapezoid init_trapz (float x1,float x2,float x3,float x4, trapz_type typ) {
	
   trapezoid trz;
   trz.a = x1;
   trz.b = x2;
   trz.c = x3;
   trz.d = x4;
   trz.tp = typ;
   switch (trz.tp) {
	   
      case regular_trapezoid:
         	 trz.l_slope = 1.0/(trz.b - trz.a);
         	 trz.r_slope = 1.0/(trz.c - trz.d);
         	 break;
	 
      case left_trapezoid:
         	 trz.r_slope = 1.0/(trz.a - trz.b);
         	 trz.l_slope = 0.0;
         	 break;
	 
      case right_trapezoid:
         	 trz.l_slope = 1.0/(trz.b - trz.a);
         	 trz.r_slope = 0.0;
         	 break;
   }  /* end switch  */
   
   return trz;
}  /* end function */

//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
float trapz (float x, trapezoid trz) {
   switch (trz.tp) {
	   
      case left_trapezoid:
         	 if (x <= trz.a)
         	    return 1.0;
         	 if (x >= trz.b)
         	    return 0.0;
         	 /* a < x < b */
         	 return trz.r_slope * (x - trz.b);
	 
	 
      case right_trapezoid:
         	 if (x <= trz.a)
         	    return 0.0;
         	 if (x >= trz.b)
         	    return 1.0;
         	 /* a < x < b */
         	 return trz.l_slope * (x - trz.a);
	 
      case regular_trapezoid:
         	 if ((x <= trz.a) || (x >= trz.d))
         	    return 0.0;
         	 if ((x >= trz.b) && (x <= trz.c))
         	    return 1.0;
         	 if ((x >= trz.a) && (x <= trz.b))
         	    return trz.l_slope * (x - trz.a);
         	 if ((x >= trz.c) && (x <= trz.d))
         	    return  trz.r_slope * (x - trz.d);
         	    
	 }  /* End switch  */
	 
   return 0.0;  /* should not get to this point */
}  /* End function */

//////////////////////////////////////////////////////////////////////////////
float min_of(float values[],int no_of_inps) {
   int i;
   float val;
   val = values [0];
   for (i = 1;i < no_of_inps;i++) {
       if (values[i] < val)
	  val = values [i];
   }
   return val;
}



//////////////////////////////////////////////////////////////////////////////
float fuzzy_system (float inputs[],fuzzy_system_rec fz) {
   int i,j;
   short variable_index,fuzzy_set;
   float sum1 = 0.0,sum2 = 0.0,weight;
   float m_values[MAX_NO_OF_INPUTS];
	
   
   for (i = 0;i < fz.no_of_rules;i++) {
      for (j = 0;j < fz.no_of_inputs;j++) {
	   variable_index = fz.rules[i].inp_index[j];
	   fuzzy_set = fz.rules[i].inp_fuzzy_set[j];
	   m_values[j] = trapz(inputs[variable_index],
	       fz.inp_mem_fns[variable_index][fuzzy_set]);
	   } /* end j  */
      
       weight = min_of (m_values,fz.no_of_inputs);
				
       sum1 += weight * fz.output_values[fz.rules[i].out_fuzzy_set];
       sum2 += weight;
   } /* end i  */
 
	
	if (fabs(sum2) < TOO_SMALL) {
      cout << "\r\nFLPRCS Error: Sum2 in fuzzy_system is 0.  Press key: " << endl;
      //~ getch();
      //~ exit(1);
      return 0.0;
   }
   
   return (sum1/sum2);
}  /* end fuzzy_system  */

//////////////////////////////////////////////////////////////////////////////
void free_fuzzy_rules (fuzzy_system_rec *fz) {
   if (fz->allocated){
	   free (fz->rules);
	}
	
   fz->allocated = false;
   return;
}

